//有一类最难的dfs需要用到贪心或者dp，比如类似dijkstra
490 the maze
本题bfs的难点就在于终止条件是什么？因为和普通的dfs越界不一样
最开始的想法是四周都是墙或者周围都停不下来
https://segmentfault.com/a/1190000017163338 这个比较好理解一些
class Solution {
    public boolean hasPath(int[][] maze, int[] start, int[] destination) {
        int m = maze.length, n = maze[0].length;
        boolean[][] visited = new boolean[m][n];
        return dfs(maze, visited, start, destination);
    }
    private boolean dfs(int[][] maze, boolean[][] visited, int[] start, int[] destination) {
        int row = start[0], col = start[1];
        
        //check boundaries and if the point visited before
        if (row < 0 || row >= maze.length || col < 0 || col >= maze[0].length || visited[row][col]) return false;
        
        //mark as a visited stop point
        visited[row][col] = true;
        
        //if stop point is destination => true
        //注意能进入dfs的前提是已经在这一点停住了（该点能成为出发点的条件是必须在这一点停住，不是所有点都能停下，因此不可能出现滑到一般的情况）
        //那样就没法写终止条件了，注意不要受传统dfs写法的困扰，看下面的遍历条件也能知道，进入下一个dfs的条件是已经停下了。
        if (row == destination[0] && col == destination[1]) return true;
        
        //DFS on four directions
        int[][] dirs = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};
        for (int i = 0; i < 4; i++) {
            int x = row, y = col;
            
            //rolling until out or hit the wall 
            while (x >= 0 && x < maze.length && y >= 0 && y < maze[0].length && maze[x][y] != 1) {
                x += dirs[i][0];
                y += dirs[i][1];
            }
            
            //back to the stop point
            x -= dirs[i][0];
            y -= dirs[i][1];
            
            //start another dfs from the stop point
            if (dfs(maze, visited, new int[]{x, y}, destination)) return true;
        }
        return false;
    }
}
505	The Maze II
499	The Maze III
贪吃蛇 
longest increasing path in a matrix
